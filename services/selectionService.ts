import { CandidateSelection, SelectionStage } from '../types';
import { supabase } from './supabase';

export class SelectionService {
    static async getAll(): Promise<CandidateSelection[]> {
        const { data, error } = await supabase
            .from('candidate_selections')
            .select('*');

        if (error) {
            console.error('Error fetching selections:', error);
            return [];
        }

        return data.map(this.mapRowToSelection);
    }

    static async getById(id: string): Promise<CandidateSelection | undefined> {
        const { data, error } = await supabase
            .from('candidate_selections')
            .select('*')
            .eq('id', id)
            .single();

        if (error) {
            console.error('Error fetching selection:', error);
            return undefined;
        }

        return this.mapRowToSelection(data);
    }

    static async getByDemandOrderId(demandOrderId: string): Promise<CandidateSelection[]> {
        const { data, error } = await supabase
            .from('candidate_selections')
            .select(`
                *,
                candidate:candidates!candidate_id (name)
            `)
            .eq('demand_order_id', demandOrderId);

        if (error) {
            console.error('Error fetching selections by demand order:', error);
            return [];
        }

        return data.map(this.mapRowToSelection);
    }

    static async getByCandidateId(candidateId: string): Promise<CandidateSelection[]> {
        const { data, error } = await supabase
            .from('candidate_selections')
            .select('*')
            .eq('candidate_id', candidateId);

        if (error) {
            console.error('Error fetching selections by candidate:', error);
            return [];
        }

        return data.map(this.mapRowToSelection);
    }

    static async getActiveByDemandOrderId(demandOrderId: string): Promise<CandidateSelection[]> {
        const { data, error } = await supabase
            .from('candidate_selections')
            .select(`
                *,
                candidate:candidates!candidate_id (name)
            `)
            .eq('demand_order_id', demandOrderId)
            .neq('stage', SelectionStage.REJECTED);

        if (error) {
            console.error('Error fetching active selections:', error);
            return [];
        }

        return data.map(this.mapRowToSelection);
    }

    static async add(selection: CandidateSelection): Promise<void> {
        // Check for duplicates handled by DB constraints or application logic?
        // Let's rely on app logic for now or simple check
        const { data: existing } = await supabase
            .from('candidate_selections')
            .select('id')
            .eq('candidate_id', selection.candidateId)
            .eq('demand_order_id', selection.demandOrderId)
            .maybeSingle();

        if (existing) return;

        const row = this.mapSelectionToRow(selection);
        // delete row.id; // Keep ID since we use frontend generated IDs (TEXT)
        // Using upsert with specified ID if provided, typically uuid is generated by DB
        // But for migration/consistency if the ID is already UUID... components generate `sel-${Date.now()}` which is NOT UUID.
        // So we should probably let DB generate UUID OR change frontend to generate UUID (which is complex).
        // Let's use the DB ID. But wait, local update relies on ID. 
        // We really should use UUIDs.
        // The components generate `sel-${Date.now()}`. This will fail UUID validation if we try to insert it into UUID column.
        // I made `id` UUID in schema.
        // So I must NOT send the frontend generated ID.
        // But `addBatch` expects to send IDs? 

        const { error } = await supabase
            .from('candidate_selections')
            .insert(row);

        if (error) {
            console.error('Error adding selection:', error);
        }
    }

    static async addBatch(newSelections: CandidateSelection[]): Promise<void> {
        // Filter out duplicates
        // Note: Use a loop or Promise.all for batch checks if needed, or rely on unique constraint?
        // We don't have unique constraint on (demand_order_id, candidate_id) in schema yet.

        for (const sel of newSelections) {
            const { data: existing } = await supabase
                .from('candidate_selections')
                .select('id')
                .eq('candidate_id', sel.candidateId)
                .eq('demand_order_id', sel.demandOrderId)
                .maybeSingle();

            if (!existing) {
                const row = this.mapSelectionToRow(sel);
                // delete row.id; // Keep ID
                await supabase.from('candidate_selections').insert(row);
            }
        }
    }

    static async update(updated: CandidateSelection): Promise<void> {
        const row = this.mapSelectionToRow(updated);
        // Ensure ID is valid UUID. If it was generated as `sel-...`, we can't update using it if the DB has UUID.
        // This implies `CandidateSelection` in frontend MUST use the UUID from DB.
        // For `add`, we ignore input ID.
        // For `update`, we need the real DB ID.
        // This means after `add`, we need to fetch the real ID? Or return it.
        // But `add` returns void here. 
        // Refactoring opportunity: `add` should return the created object.

        const { error } = await supabase
            .from('candidate_selections')
            .update(row)
            .eq('id', updated.id);

        if (error) {
            console.error('Error updating selection:', error);
        }
    }

    static async advanceStage(selectionId: string, toStage: SelectionStage): Promise<CandidateSelection | null> {
        const { data, error } = await supabase
            .from('candidate_selections')
            .update({
                stage: toStage,
                updated_at: new Date().toISOString()
            })
            .eq('id', selectionId)
            .select()
            .single();

        if (error) {
            console.error('Error advancing stage:', error);
            return null;
        }

        return this.mapRowToSelection(data);
    }

    static async rejectCandidate(selectionId: string, reason: string): Promise<void> {
        const { error } = await supabase
            .from('candidate_selections')
            .update({
                stage: SelectionStage.REJECTED,
                rejection_reason: reason,
                updated_at: new Date().toISOString()
            })
            .eq('id', selectionId);

        if (error) {
            console.error('Error rejecting candidate:', error);
        }
    }

    static async delete(id: string): Promise<void> {
        const { error } = await supabase
            .from('candidate_selections')
            .delete()
            .eq('id', id);

        if (error) console.error('Error deleting selection:', error);
    }

    static getStageOrder(): SelectionStage[] {
        return [
            SelectionStage.MATCHED,
            SelectionStage.CV_SUBMITTED,
            SelectionStage.SHORTLISTED,
            SelectionStage.INTERVIEW_SCHEDULED,
            SelectionStage.INTERVIEWED,
            SelectionStage.SELECTED,
            SelectionStage.OFFER_ISSUED,
            SelectionStage.OFFER_ACCEPTED,
        ];
    }

    static async getStageCounts(demandOrderId: string): Promise<Record<SelectionStage, number>> {
        const { data, error } = await supabase
            .from('candidate_selections')
            .select('stage')
            .eq('demand_order_id', demandOrderId);

        const counts: Record<string, number> = {};
        for (const stage of Object.values(SelectionStage)) {
            counts[stage] = 0;
        }

        if (!error && data) {
            for (const row of data) {
                counts[row.stage] = (counts[row.stage] || 0) + 1;
            }
        }
        return counts as Record<SelectionStage, number>;
    }

    private static mapRowToSelection(row: any): CandidateSelection {
        return {
            id: row.id,
            demandOrderId: row.demand_order_id,
            candidateId: row.candidate_id,
            candidateName: row.candidate?.name || 'Unknown', // Join performed in query
            stage: row.stage as SelectionStage,
            interviewDate: row.interview_date,
            interviewType: row.interview_type,
            interviewNotes: row.interview_notes,
            employerFeedback: row.employer_feedback,
            offerSalary: row.offer_salary,
            offerDate: row.offer_date,
            rejectionReason: row.rejection_reason,
            matchScore: row.match_score,
            createdAt: row.created_at,
            updatedAt: row.updated_at
        };
    }

    private static mapSelectionToRow(selection: CandidateSelection): any {
        return {
            id: selection.id,
            demand_order_id: selection.demandOrderId,
            candidate_id: selection.candidateId,
            stage: selection.stage,
            interview_date: selection.interviewDate,
            interview_type: selection.interviewType,
            interview_notes: selection.interviewNotes,
            employer_feedback: selection.employerFeedback,
            offer_salary: selection.offerSalary,
            offer_date: selection.offerDate,
            rejection_reason: selection.rejectionReason,
            match_score: selection.matchScore,
            updated_at: new Date().toISOString()
            // created_at is not updated
        };
    }
}
